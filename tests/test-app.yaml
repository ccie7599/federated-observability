---
apiVersion: v1
kind: Namespace
metadata:
  name: test-app
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-app-html
  namespace: test-app
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head>
        <title>Federated Observability - Test App</title>
        <style>
            body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }
            .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
            .success { background: #d4edda; color: #155724; }
            .error { background: #f8d7da; color: #721c24; }
            button { padding: 10px 20px; margin: 5px; cursor: pointer; }
            #results { margin-top: 20px; }
            pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
        </style>
    </head>
    <body>
        <h1>Federated Observability Test App</h1>
        <p>Use the buttons below to generate test telemetry data.</p>

        <h2>Generate Telemetry</h2>
        <button onclick="generateTrace()">Generate Trace</button>
        <button onclick="generateMetrics()">Generate Metrics</button>
        <button onclick="generateLog()">Generate Log</button>
        <button onclick="generateError()">Generate Error</button>
        <button onclick="runLoadTest()">Run Load Test (10 requests)</button>

        <h2>Health Checks</h2>
        <button onclick="checkHealth()">Check App Health</button>
        <button onclick="checkMetrics()">View Metrics</button>

        <div id="results"></div>

        <script>
            const resultsDiv = document.getElementById('results');

            function showResult(message, isError = false) {
                const div = document.createElement('div');
                div.className = 'status ' + (isError ? 'error' : 'success');
                div.innerHTML = '<strong>' + new Date().toISOString() + '</strong>: ' + message;
                resultsDiv.insertBefore(div, resultsDiv.firstChild);
            }

            async function generateTrace() {
                try {
                    const res = await fetch('/api/trace');
                    const data = await res.json();
                    showResult('Trace generated: ' + JSON.stringify(data));
                } catch (e) {
                    showResult('Error: ' + e.message, true);
                }
            }

            async function generateMetrics() {
                try {
                    const res = await fetch('/api/metrics-test');
                    const data = await res.json();
                    showResult('Metrics incremented: ' + JSON.stringify(data));
                } catch (e) {
                    showResult('Error: ' + e.message, true);
                }
            }

            async function generateLog() {
                try {
                    const res = await fetch('/api/log');
                    const data = await res.json();
                    showResult('Log generated: ' + JSON.stringify(data));
                } catch (e) {
                    showResult('Error: ' + e.message, true);
                }
            }

            async function generateError() {
                try {
                    const res = await fetch('/api/error');
                    const data = await res.json();
                    showResult('Error generated: ' + JSON.stringify(data));
                } catch (e) {
                    showResult('Expected error: ' + e.message, true);
                }
            }

            async function runLoadTest() {
                showResult('Starting load test...');
                for (let i = 0; i < 10; i++) {
                    await generateTrace();
                    await new Promise(r => setTimeout(r, 100));
                }
                showResult('Load test complete!');
            }

            async function checkHealth() {
                try {
                    const res = await fetch('/health');
                    const data = await res.json();
                    showResult('Health: ' + JSON.stringify(data));
                } catch (e) {
                    showResult('Error: ' + e.message, true);
                }
            }

            async function checkMetrics() {
                try {
                    const res = await fetch('/metrics');
                    const text = await res.text();
                    showResult('<pre>' + text.substring(0, 1000) + '...</pre>');
                } catch (e) {
                    showResult('Error: ' + e.message, true);
                }
            }
        </script>
    </body>
    </html>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: test-app
  labels:
    app: test-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
        - name: test-app
          image: python:3.11-slim
          command:
            - /bin/sh
            - -c
            - |
              pip install flask prometheus-client opentelemetry-api opentelemetry-sdk \
                opentelemetry-exporter-otlp opentelemetry-instrumentation-flask && \
              python /app/server.py
          ports:
            - containerPort: 8080
              name: http
          env:
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-agent.observability:4317"
            - name: OTEL_SERVICE_NAME
              value: "test-app"
            - name: OTEL_RESOURCE_ATTRIBUTES
              value: "service.namespace=test-app,deployment.environment=test"
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          volumeMounts:
            - name: app-code
              mountPath: /app
            - name: html
              mountPath: /static
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 5
      volumes:
        - name: app-code
          configMap:
            name: test-app-code
        - name: html
          configMap:
            name: test-app-html
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-app-code
  namespace: test-app
data:
  server.py: |
    import os
    import time
    import random
    import logging
    from flask import Flask, jsonify, send_from_directory
    from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    from opentelemetry import trace
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.trace.export import BatchSpanProcessor
    from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
    from opentelemetry.sdk.resources import Resource
    from opentelemetry.instrumentation.flask import FlaskInstrumentor

    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
    logger = logging.getLogger(__name__)

    # Configure OpenTelemetry
    resource = Resource.create({
        "service.name": os.getenv("OTEL_SERVICE_NAME", "test-app"),
        "service.namespace": "test-app",
        "pod.name": os.getenv("POD_NAME", "unknown"),
    })

    provider = TracerProvider(resource=resource)
    otlp_endpoint = os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4317")

    try:
        exporter = OTLPSpanExporter(endpoint=otlp_endpoint, insecure=True)
        provider.add_span_processor(BatchSpanProcessor(exporter))
        trace.set_tracer_provider(provider)
        logger.info(f"OpenTelemetry configured with endpoint: {otlp_endpoint}")
    except Exception as e:
        logger.warning(f"Failed to configure OTLP exporter: {e}")

    tracer = trace.get_tracer(__name__)

    # Prometheus metrics
    REQUEST_COUNT = Counter('test_app_requests_total', 'Total requests', ['method', 'endpoint', 'status'])
    REQUEST_LATENCY = Histogram('test_app_request_latency_seconds', 'Request latency', ['endpoint'])
    ERROR_COUNT = Counter('test_app_errors_total', 'Total errors', ['type'])

    app = Flask(__name__)
    FlaskInstrumentor().instrument_app(app)

    @app.route('/')
    def index():
        REQUEST_COUNT.labels(method='GET', endpoint='/', status='200').inc()
        return send_from_directory('/static', 'index.html')

    @app.route('/health')
    def health():
        return jsonify({"status": "healthy", "pod": os.getenv("POD_NAME", "unknown")})

    @app.route('/metrics')
    def metrics():
        return generate_latest(), 200, {'Content-Type': CONTENT_TYPE_LATEST}

    @app.route('/api/trace')
    def generate_trace():
        with tracer.start_as_current_span("test-trace") as span:
            span.set_attribute("test.type", "manual")
            span.set_attribute("test.timestamp", time.time())

            # Simulate some work
            with tracer.start_as_current_span("database-query"):
                time.sleep(random.uniform(0.01, 0.05))

            with tracer.start_as_current_span("external-api-call"):
                time.sleep(random.uniform(0.02, 0.1))

            REQUEST_COUNT.labels(method='GET', endpoint='/api/trace', status='200').inc()
            logger.info("Generated test trace", extra={"trace_id": format(span.get_span_context().trace_id, '032x')})

            return jsonify({
                "status": "trace_generated",
                "trace_id": format(span.get_span_context().trace_id, '032x'),
                "span_id": format(span.get_span_context().span_id, '016x')
            })

    @app.route('/api/metrics-test')
    def metrics_test():
        with REQUEST_LATENCY.labels(endpoint='/api/metrics-test').time():
            REQUEST_COUNT.labels(method='GET', endpoint='/api/metrics-test', status='200').inc()
            time.sleep(random.uniform(0.01, 0.05))
            logger.info("Metrics test endpoint called")
            return jsonify({"status": "metrics_incremented"})

    @app.route('/api/log')
    def generate_log():
        REQUEST_COUNT.labels(method='GET', endpoint='/api/log', status='200').inc()
        logger.info("Test log message - INFO level")
        logger.warning("Test log message - WARNING level")
        logger.debug("Test log message - DEBUG level")
        return jsonify({"status": "logs_generated"})

    @app.route('/api/error')
    def generate_error():
        ERROR_COUNT.labels(type='test_error').inc()
        REQUEST_COUNT.labels(method='GET', endpoint='/api/error', status='500').inc()
        logger.error("Test error message - ERROR level", exc_info=False)

        with tracer.start_as_current_span("error-span") as span:
            span.set_attribute("error", True)
            span.set_attribute("error.type", "TestError")
            span.record_exception(Exception("Test exception for observability"))

        return jsonify({"status": "error_generated", "error": "Test error"}), 500

    if __name__ == '__main__':
        logger.info("Starting test app server...")
        app.run(host='0.0.0.0', port=8080)
---
apiVersion: v1
kind: Service
metadata:
  name: test-app
  namespace: test-app
  labels:
    app: test-app
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8080
      name: http
  selector:
    app: test-app
